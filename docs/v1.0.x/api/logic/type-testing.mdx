---
title: "Type Testing"
description: "Element-wise and whole-object tests for NaN, infinity, finiteness, complex type, scalar type, dtype kind, and more."
---

### isnan

Test element-wise for NaN.

```typescript
function isnan(x: ArrayLike): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `ArrayLike` | -- | Input array. |

**Returns:** `NDArray` -- Boolean array, `true` where `x` is `NaN`.

```typescript
import * as np from 'numpy-ts';

const result = np.isnan([1, NaN, Infinity, 0]);
// array([false, true, false, false])
```

---

### isinf

Test element-wise for positive or negative infinity.

```typescript
function isinf(x: ArrayLike): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `ArrayLike` | -- | Input array. |

**Returns:** `NDArray` -- Boolean array, `true` where `x` is `+Inf` or `-Inf`.

```typescript
import * as np from 'numpy-ts';

const result = np.isinf([1, Infinity, -Infinity, NaN]);
// array([false, true, true, false])
```

---

### isfinite

Test element-wise for finiteness (not infinity and not NaN).

```typescript
function isfinite(x: ArrayLike): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `ArrayLike` | -- | Input array. |

**Returns:** `NDArray` -- Boolean array, `true` where `x` is finite.

```typescript
import * as np from 'numpy-ts';

const result = np.isfinite([1, 0, Infinity, NaN, -Infinity]);
// array([true, true, false, false, false])
```

---

### isneginf

Test element-wise for negative infinity.

```typescript
function isneginf(x: ArrayLike): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `ArrayLike` | -- | Input array. |

**Returns:** `NDArray` -- Boolean array, `true` where `x` is `-Infinity`.

```typescript
import * as np from 'numpy-ts';

const result = np.isneginf([1, -Infinity, Infinity, NaN]);
// array([false, true, false, false])
```

---

### isposinf

Test element-wise for positive infinity.

```typescript
function isposinf(x: ArrayLike): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `ArrayLike` | -- | Input array. |

**Returns:** `NDArray` -- Boolean array, `true` where `x` is `+Infinity`.

```typescript
import * as np from 'numpy-ts';

const result = np.isposinf([1, -Infinity, Infinity, NaN]);
// array([false, false, true, false])
```

---

### iscomplex

Test element-wise whether values are complex (have non-zero imaginary part).

```typescript
function iscomplex(x: ArrayLike): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `ArrayLike` | -- | Input array. |

**Returns:** `NDArray` -- Boolean array, `true` where the element has a non-zero imaginary part.

```typescript
import * as np from 'numpy-ts';

const a = np.array([1, 2, 3], 'complex128');
const result = np.iscomplex(a);
// array([false, false, false])  -- real values stored as complex
```

---

### iscomplexobj

Return `true` if the input is a complex-typed array or has complex dtype.

```typescript
function iscomplexobj(x: any): boolean
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `any` | -- | Input to check. |

**Returns:** `boolean` -- `true` if `x` is an array with complex dtype (`complex64` or `complex128`).

```typescript
import * as np from 'numpy-ts';

np.iscomplexobj(np.array([1, 2], 'complex128'));
// true

np.iscomplexobj(np.array([1, 2], 'float64'));
// false
```

---

### isreal

Test element-wise whether values are real (have zero imaginary part).

```typescript
function isreal(x: ArrayLike): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `ArrayLike` | -- | Input array. |

**Returns:** `NDArray` -- Boolean array, `true` where the element has zero imaginary part.

```typescript
import * as np from 'numpy-ts';

const a = np.array([1, 2, 3]);
const result = np.isreal(a);
// array([true, true, true])
```

---

### isrealobj

Return `true` if the input is not a complex-typed array.

```typescript
function isrealobj(x: any): boolean
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `any` | -- | Input to check. |

**Returns:** `boolean` -- `true` if `x` is not a complex array (i.e., dtype is not `complex64` or `complex128`).

```typescript
import * as np from 'numpy-ts';

np.isrealobj(np.array([1, 2, 3]));
// true

np.isrealobj(np.array([1, 2], 'complex128'));
// false
```

---

### isscalar

Return `true` if the input is a scalar value (number, boolean, bigint, or string).

```typescript
function isscalar(element: any): boolean
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `element` | `any` | -- | Value to test. |

**Returns:** `boolean` -- `true` if `element` is a scalar type.

```typescript
import * as np from 'numpy-ts';

np.isscalar(3.14);      // true
np.isscalar(true);       // true
np.isscalar('hello');    // true
np.isscalar([1, 2, 3]); // false
np.isscalar(np.array([1])); // false
```

---

### isnat

Test element-wise for Not-a-Time. Since numpy-ts does not implement datetime dtypes, this always returns `false` for every element. Included for API compatibility with NumPy.

```typescript
function isnat(x: ArrayLike): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `x` | `ArrayLike` | -- | Input array. |

**Returns:** `NDArray` -- Boolean array of all `false` values (datetime dtypes are not supported).

```typescript
import * as np from 'numpy-ts';

const result = np.isnat([1, 2, NaN]);
// array([false, false, false])
```

---

### isfortran

Return `true` if the array is Fortran-contiguous and not C-contiguous.

```typescript
function isfortran(a: ArrayLike): boolean
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `a` | `ArrayLike` | -- | Input array. |

**Returns:** `boolean` -- `true` if the array is Fortran-contiguous (column-major) and not C-contiguous. In numpy-ts, arrays are always C-contiguous, so this typically returns `false`.

```typescript
import * as np from 'numpy-ts';

const a = np.array([[1, 2], [3, 4]]);
np.isfortran(a);
// false (numpy-ts arrays are C-contiguous)
```

---

### iterable

Return `true` if the input can be iterated over.

```typescript
function iterable(y: any): boolean
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `y` | `any` | -- | Value to test. |

**Returns:** `boolean` -- `true` if `y` is iterable (arrays, NDArrays, strings, etc.).

```typescript
import * as np from 'numpy-ts';

np.iterable([1, 2, 3]);          // true
np.iterable(np.array([1, 2]));   // true
np.iterable(42);                  // false
```

---

### isdtype

Test whether a dtype belongs to a specified kind or set of dtypes.

```typescript
function isdtype(dtype: DType, kind: string | DType | DType[]): boolean
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `dtype` | `DType` | -- | The dtype to test. |
| `kind` | `string \| DType \| DType[]` | -- | A dtype kind string (e.g., `'integral'`, `'real floating'`, `'numeric'`), a single `DType`, or an array of `DType` values to match against. |

**Returns:** `boolean` -- `true` if `dtype` matches the specified kind.

```typescript
import * as np from 'numpy-ts';

np.isdtype('float64', 'real floating');
// true

np.isdtype('int32', 'integral');
// true

np.isdtype('float32', ['float32', 'float64']);
// true

np.isdtype('int32', 'real floating');
// false
```

---

### real_if_close

If the imaginary part of an array is close to zero, return only the real part. Otherwise, return the input unchanged.

```typescript
function real_if_close(a: ArrayLike, tol?: number): NDArray
```

| Name | Type | Default | Description |
|------|------|---------|-------------|
| `a` | `ArrayLike` | -- | Input array. |
| `tol` | `number` | `100` | Tolerance factor. The imaginary part is considered close to zero if `max(abs(imag)) < tol * eps` where `eps` is the machine epsilon for the dtype. |

**Returns:** `NDArray` -- Real-valued array if the imaginary part is negligible, otherwise the original array.

```typescript
import * as np from 'numpy-ts';

// Imaginary part is negligibly small
const a = np.array([1 + 1e-15, 2 + 0, 3 - 1e-15], 'complex128');
const result = np.real_if_close(a);
// array([1, 2, 3])  -- returned as real float64
```
