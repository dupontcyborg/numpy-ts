---
title: "Performance Tips"
description: "Optimize numpy-ts usage: avoid unnecessary copies, leverage views, tree-shake bundles, choose efficient dtypes, and prefer vectorized operations."
---

import { Playground } from '/snippets/Playground.jsx'

## Vectorized operations vs loops

Always prefer vectorized operations over JavaScript loops. numpy-ts operations run on typed arrays with optimized internal loops, avoiding the overhead of JavaScript function calls and dynamic type checks.

<Playground
  code={[
    "const n = 1000000;",
    "const a = np.random.random([n]);",
    "const b = np.random.random([n]);",
    "",
    "// BAD: JavaScript loop (slow)",
    "const t0 = performance.now();",
    "const resultLoop = np.zeros([n]);",
    "const aArr = a.toArray();",
    "const bArr = b.toArray();",
    "for (let i = 0; i < n; i++) {",
    "  // Each iteration has JS overhead",
    "  resultLoop.set([i], Math.sqrt(aArr[i] * aArr[i] + bArr[i] * bArr[i]));",
    "}",
    "const t1 = performance.now();",
    "console.log('Loop time (ms):', (t1 - t0).toFixed(2), '\\n');",
    "",
    "// GOOD: Vectorized (fast)",
    "const t2 = performance.now();",
    "const resultVec = np.power(a, 2).add(np.power(b, 2)).sqrt();",
    "const t3 = performance.now();",
    "console.log('Vectorized time (ms):', (t3 - t2).toFixed(2), '\\n');",
    "console.log('Speedup:', ((t1 - t0) / (t3 - t2)).toFixed(2) + 'x');",
    "",
    "// Sanity check: compare arrays (max absolute difference)",
    "const diff = np.abs(np.subtract(resultLoop, resultVec));",
    "const maxDiff = np.amax(diff);",
    "console.log('Results match:', maxDiff < 0.001 ? true : false);",
  ].join("\n")}
  showImportHeader={true}
  showCopyButton={true}
/>

### Common loop-to-vectorized translations

| Loop pattern | Vectorized equivalent |
|---|---|
| `for (i) result[i] = a[i] + b[i]` | `np.add(a, b)` |
| `for (i) result[i] = a[i] > threshold ? 1 : 0` | `np.greater(a, threshold)` |
| `for (i) sum += a[i]` | `np.sum(a)` |
| `for (i) result[i] = Math.max(a[i], 0)` | `np.maximum(a, 0)` |
| `for (i) if (mask[i]) result.push(a[i])` | `np.extract(mask, a)` |
| `for (i) result[i] = condition ? x[i] : y[i]` | `np.where(condition, x, y)` |

---

## Avoiding unnecessary copies (use views when possible)

Views share the same underlying data buffer as the original array. Operations that return views are effectively free -- no memory allocation and no data copying.

<Playground
  code={String.raw`const data = np.arange(1000000);  // 1 million elements

// These return views (fast, no copy):
const reshaped = np.reshape(data, [1000, 1000]); // view
const transposed = reshaped.T;                    // view
const sliced = reshaped.slice('0:500', ':');       // view
const squeezed = np.expand_dims(data, 0);         // view

// These always copy (allocate new memory):
const flattened = np.flatten(transposed); // copy (transpose is not contiguous)
const copied = np.copy(data);            // explicit copy
const tiled = np.tile(data, [2]);         // copy`}
  showImportHeader={true}
  showCopyButton={true}
/>

### Check whether an operation returned a view

<Playground
  code={String.raw`const a = np.arange(12).reshape([3, 4]);
const b = a.slice('0:2', ':');

console.log(b.flags.OWNDATA, '\n');
console.log(b.base === a, '\n');

const c = np.flatten(a);
console.log(c.flags.OWNDATA, '\n');`}
  showImportHeader={true}
  showCopyButton={true}
/>

<Warning>
Views share data. Modifying a view changes the original array. If you need an independent copy, use `np.copy()` or `.copy()`.
</Warning>

---

## Dtype selection for memory efficiency

Choose the smallest dtype that can represent your data. This reduces memory usage and can improve cache performance.

<Playground
  code={String.raw`// Default float64: 8 bytes per element
const f64 = np.zeros([1000, 1000]);            // ~8 MB
console.log(f64.tobytes().byteLength);

// float32: 4 bytes per element, sufficient for most ML/graphics
const f32 = np.zeros([1000, 1000], 'float32'); // ~4 MB
console.log(f32.tobytes().byteLength);

// int8: 1 byte per element, good for small integer data
const i8 = np.zeros([1000, 1000], 'int8');     // ~1 MB
console.log(i8.tobytes().byteLength);`}
  showImportHeader={true}
  showCopyButton={true}
/>

### Dtype selection guide

| Data type | Bytes | Use when |
|---|---|---|
| `float64` | 8 | Maximum precision needed, scientific computation |
| `float32` | 4 | ML inference, graphics, when 7 digits of precision suffice |
| `int32` | 4 | Integer data up to ~2 billion |
| `int16` | 2 | Audio samples, small integer ranges |
| `int8` / `uint8` | 1 | Pixel values, boolean-like data, lookup indices |
| `bool` | 1 | Masks and boolean arrays |

<Tip>
Use `.astype()` to convert between dtypes. Going from a wider type to a narrower one truncates (float to int) or wraps (large int to small int).
</Tip>

---

## Using keepdims for broadcasting

When reducing along an axis, the reduced dimension disappears by default. Use `keepdims: true` to preserve it as a size-1 dimension, which makes subsequent broadcasting operations work without manual reshaping.

<Playground
  code={String.raw`const data = np.array([[1, 2, 3], [4, 5, 6]]);  // shape [2, 3]

// Without keepdims: shape [2] -- cannot directly broadcast with [2, 3]
const rowMeans = np.mean(data, 1);
console.log(rowMeans.shape, '\n');
// np.subtract(data, rowMeans) -- would need reshape

// With keepdims: shape [2, 1] -- broadcasts naturally with [2, 3]
const rowMeansKept = np.mean(data, 1, true);
console.log(rowMeansKept.shape, '\n');

// Center the data (subtract row means) -- no reshape needed
const centered = np.subtract(data, rowMeansKept);
console.log(centered, '\n');

// Normalize columns to zero mean, unit variance
const colMean = np.mean(data, 0, true);   // shape [1, 3]
const colStd = np.std(data, 0, undefined, true);    // shape [1, 3]
const normalized = np.divide(np.subtract(data, colMean), colStd);
console.log(normalized, '\n');`}
  showImportHeader={true}
  showCopyButton={true}
/>