---
title: "Signal Processing with FFT"
description: "Build signals, compute Fourier transforms, filter frequencies, and apply convolution using numpy-ts."
---

## Creating a composite signal

Build a signal by summing sine waves at different frequencies. This is the starting point for most frequency-domain analysis.

```typescript
import * as np from 'numpy-ts';

// Sampling parameters
const sampleRate = 256;  // Hz
const duration = 1;      // seconds
const N = sampleRate * duration;

// Time vector: 256 samples over 1 second
const t = np.linspace(0, duration, N);

// Create a composite signal: 5 Hz + 20 Hz + 50 Hz
const freq1 = 5, freq2 = 20, freq3 = 50;

const signal = np.add(
  np.add(
    np.sin(np.multiply(t, 2 * Math.PI * freq1)),
    np.multiply(np.sin(np.multiply(t, 2 * Math.PI * freq2)), 0.5)
  ),
  np.multiply(np.sin(np.multiply(t, 2 * Math.PI * freq3)), 0.3)
);

console.log('Signal shape:', signal.shape);  // [256]
console.log('Signal dtype:', signal.dtype);  // 'float64'
```

---

## Computing the FFT and finding frequency components

The FFT converts a time-domain signal into its frequency-domain representation, revealing which frequencies are present.

```typescript
import * as np from 'numpy-ts';

// Assume signal and sampleRate from above
const N = 256;
const sampleRate = 256;

const t = np.linspace(0, 1, N);
const signal = np.add(
  np.sin(np.multiply(t, 2 * Math.PI * 5)),
  np.multiply(np.sin(np.multiply(t, 2 * Math.PI * 20)), 0.5)
);

// Compute the FFT
const spectrum = np.fft.fft(signal);
console.log('Spectrum shape:', spectrum.shape);   // [256]
console.log('Spectrum dtype:', spectrum.dtype);    // 'complex128'

// Get the frequency bins
const freqs = np.fft.fftfreq(N, 1 / sampleRate);

// Compute the magnitude (absolute value of complex spectrum)
const magnitude = np.absolute(spectrum);

// Only the first half is meaningful for real signals (positive frequencies)
const halfN = Math.floor(N / 2);
const posFreqs = freqs.slice(`0:${halfN}`);
const posMag = magnitude.slice(`0:${halfN}`);

// Normalize magnitude
const normalizedMag = np.divide(posMag, N / 2);

// Find peaks: frequencies where magnitude is above a threshold
console.log('Frequency components detected at the peak magnitudes');
// The peaks will appear at 5 Hz (amplitude ~1.0) and 20 Hz (amplitude ~0.5)
```

---

## Filtering frequencies and inverse FFT

Remove unwanted frequencies by zeroing out their components in the frequency domain, then transform back to the time domain.

```typescript
import * as np from 'numpy-ts';

const N = 256;
const sampleRate = 256;
const t = np.linspace(0, 1, N);

// Noisy signal: 10 Hz clean signal + 60 Hz noise
const clean = np.sin(np.multiply(t, 2 * Math.PI * 10));
const noise = np.multiply(np.sin(np.multiply(t, 2 * Math.PI * 60)), 0.8);
const noisy = np.add(clean, noise);

// Transform to frequency domain
const spectrum = np.fft.fft(noisy);
const freqs = np.fft.fftfreq(N, 1 / sampleRate);

// Create a low-pass filter: zero out frequencies above 30 Hz
const absFreqs = np.absolute(freqs);
const mask = np.less_equal(absFreqs, 30);  // true where |freq| <= 30 Hz

// Apply the filter by multiplying spectrum with the mask
const filtered = np.multiply(spectrum, mask);

// Transform back to time domain
const recovered = np.fft.ifft(filtered);

// The result is complex, take the real part
const recoveredReal = np.real(recovered);

// recoveredReal should closely match the original 10 Hz clean signal
console.log('Filtered signal shape:', recoveredReal.shape); // [256]
```

---

## Using fftfreq and fftshift

`fftfreq` returns the frequency bins for each FFT output element. `fftshift` rearranges the output so that the zero-frequency component is at the center, which is the standard convention for visualization.

```typescript
import * as np from 'numpy-ts';

const N = 8;
const sampleSpacing = 1 / 8;  // 8 Hz sample rate

// fftfreq returns frequencies in "standard" order:
// [0, 1, 2, 3, -4, -3, -2, -1] * (sampleRate / N)
const freqs = np.fft.fftfreq(N, sampleSpacing);
console.log(freqs.toString());
// array([ 0.,  1.,  2.,  3., -4., -3., -2., -1.])

// fftshift centers the zero frequency:
// [-4, -3, -2, -1, 0, 1, 2, 3] * (sampleRate / N)
const shiftedFreqs = np.fft.fftshift(freqs);
console.log(shiftedFreqs.toString());
// array([-4., -3., -2., -1.,  0.,  1.,  2.,  3.])

// For real-valued signals, rfftfreq returns only the positive frequencies
const rfreqs = np.fft.rfftfreq(N, sampleSpacing);
console.log(rfreqs.toString());
// array([0., 1., 2., 3., 4.])

// Use ifftshift to undo the shift before calling ifft
const unshifted = np.fft.ifftshift(shiftedFreqs);
console.log(np.allclose(unshifted, freqs)); // true
```

---

## Convolution with a kernel

Convolution is fundamental to signal processing -- it is used for smoothing, differentiation, edge detection, and more. numpy-ts provides `convolve` for 1-D convolution.

```typescript
import * as np from 'numpy-ts';

// Create a noisy step signal
const step = np.concatenate([np.zeros([50]), np.ones([50])]);
np.random.seed(42);
const noisy = np.add(step, np.multiply(np.random.normal(0, 1, [100]), 0.3));

// Moving average kernel (smoothing filter)
const kernelSize = 7;
const smoothKernel = np.full([kernelSize], 1.0 / kernelSize);

// Apply convolution
const smoothed = np.convolve(noisy, smoothKernel, 'same');
console.log('Smoothed signal shape:', smoothed.shape); // [100]

// Differentiation kernel (first derivative approximation)
const diffKernel = np.array([-1, 0, 1]);
const derivative = np.convolve(step, diffKernel, 'same');
// derivative will spike at the step transition

// Edge detection kernel (Laplacian approximation)
const edgeKernel = np.array([1, -2, 1]);
const edges = np.convolve(step, edgeKernel, 'same');

console.log('Derivative shape:', derivative.shape);  // [100]
console.log('Edges shape:', edges.shape);            // [100]
```

<Note>
The `'same'` mode returns output with the same length as the input, `'full'` returns the full convolution (length M+N-1), and `'valid'` returns only the part computed without zero-padded edges.
</Note>

---

## Real FFT for real-valued signals

When your input is purely real (no imaginary component), `rfft` is more efficient than `fft` because it exploits the conjugate symmetry of the spectrum.

```typescript
import * as np from 'numpy-ts';

const N = 1024;
const t = np.linspace(0, 1, N);
const signal = np.sin(np.multiply(t, 2 * Math.PI * 50));

// rfft is ~2x faster and returns only positive frequencies
const rfftResult = np.fft.rfft(signal);
console.log('rfft output length:', rfftResult.shape[0]); // 513 (N/2 + 1)

// Corresponding frequencies
const rfreqs = np.fft.rfftfreq(N, 1.0 / N);
console.log('Frequency bins:', rfreqs.shape[0]); // 513

// Inverse: irfft recovers the original real signal
const recovered = np.fft.irfft(rfftResult);
console.log('Recovered shape:', recovered.shape); // [1024]
console.log(np.allclose(recovered, signal)); // true
```
