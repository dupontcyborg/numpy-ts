---
title: "Signal Processing with FFT"
description: "Build signals, compute Fourier transforms, filter frequencies, and apply convolution using numpy-ts."
---

import { Playground } from '/snippets/Playground.jsx'

## Creating a composite signal

Build a signal by summing sine waves at different frequencies. This is the starting point for most frequency-domain analysis.

<Playground
  code={String.raw`// Sampling parameters
const sampleRate = 256;  // Hz
const duration = 1;      // seconds
const N = sampleRate * duration;

// Time vector: 256 samples over 1 second
const t = np.linspace(0, duration, N);

// Create a composite signal: 5 Hz + 20 Hz + 50 Hz
const freq1 = 5, freq2 = 20, freq3 = 50;

const wave1 = t.multiply(2 * Math.PI * freq1).sin();
const wave2 = t.multiply(2 * Math.PI * freq2).sin().multiply(0.5);
const wave3 = t.multiply(2 * Math.PI * freq3).sin().multiply(0.3);
const signal = wave1.add(wave2).add(wave3);

console.log('Signal shape:', signal.shape);
console.log('Signal dtype:', signal.dtype, '\n');

// Verify: signal should oscillate between roughly -1.8 and +1.8
console.log('Min value:', Number(np.min(signal)).toFixed(4));
console.log('Max value:', Number(np.max(signal)).toFixed(4));
console.log('Mean (should be ~0):', Number(np.mean(signal)).toFixed(4), '\n');

// First few samples (signal starts near 0 since sin(0)=0)
console.log('First 5 samples:', signal.slice('0:5'));`}
  showImportHeader={true}
  showCopyButton={true}
/>

---

## Computing the FFT and finding frequency components

The FFT converts a time-domain signal into its frequency-domain representation, revealing which frequencies are present.

<Playground
  code={String.raw`// Assume signal and sampleRate from above
const N = 256;
const sampleRate = 256;

const t = np.linspace(0, 1, N);
const wave1 = t.multiply(2 * Math.PI * 5).sin();
const wave2 = t.multiply(2 * Math.PI * 20).sin().multiply(0.5);
const signal = wave1.add(wave2);

// Compute the FFT
const spectrum = np.fft.fft(signal);
console.log('Spectrum shape:', spectrum.shape);
console.log('Spectrum dtype:', spectrum.dtype, '\n');

// Get the frequency bins
const freqs = np.fft.fftfreq(N, 1 / sampleRate);

// Compute the magnitude (absolute value of complex spectrum)
const magnitude = np.absolute(spectrum);

// Only the first half is meaningful for real signals (positive frequencies)
const halfN = Math.floor(N / 2);
const posFreqs = freqs.slice('0:' + halfN);
const posMag = magnitude.slice('0:' + halfN);

// Normalize magnitude
const normalizedMag = np.divide(posMag, N / 2);

// Find the top 2 peaks by sorting magnitudes
const sorted = np.argsort(np.multiply(normalizedMag, -1));
const i0 = Number(sorted.get([0]));
const i1 = Number(sorted.get([1]));

console.log('Peak 1: ' + Number(posFreqs.get([i0])) + ' Hz (amplitude: ' + Number(normalizedMag.get([i0])).toFixed(3) + ')');
console.log('Peak 2: ' + Number(posFreqs.get([i1])) + ' Hz (amplitude: ' + Number(normalizedMag.get([i1])).toFixed(3) + ')');
console.log('\nExpected: 5 Hz (amplitude ~1.0) and 20 Hz (amplitude ~0.5)');`}
  showImportHeader={true}
  showCopyButton={true}
/>

---

## Filtering frequencies and inverse FFT

Remove unwanted frequencies by zeroing out their components in the frequency domain, then transform back to the time domain.

<Playground
  code={String.raw`const N = 256;
const sampleRate = 256;
const t = np.linspace(0, 1, N);

// Noisy signal: 10 Hz clean signal + 60 Hz noise
const clean = np.sin(np.multiply(t, 2 * Math.PI * 10));
const noise = np.multiply(np.sin(np.multiply(t, 2 * Math.PI * 60)), 0.8);
const noisy = np.add(clean, noise);

// Transform to frequency domain
const spectrum = np.fft.fft(noisy);
const freqs = np.fft.fftfreq(N, 1 / sampleRate);

// Create a low-pass filter: zero out frequencies above 30 Hz
const absFreqs = np.absolute(freqs);
const mask = np.less_equal(absFreqs, 30);  // true where |freq| <= 30 Hz

// Apply the filter by multiplying spectrum with the mask
const filtered = np.multiply(spectrum, mask);

// Transform back to time domain
const recovered = np.fft.ifft(filtered);

// The result is complex, take the real part
const recoveredReal = np.real(recovered);

// Validate: recovered signal should closely match the original clean signal
const error = np.subtract(recoveredReal, clean);
const maxErr = Number(np.max(np.absolute(error)));
const meanErr = Number(np.mean(np.absolute(error)));
console.log('Filtered signal shape:', recoveredReal.shape);
console.log('Mean absolute error:', meanErr.toFixed(6));
console.log('Max absolute error:', maxErr.toFixed(6), '(Gibbs ringing from sharp cutoff)', '\n');

// The 60 Hz noise is gone — compare std dev before and after
const noisyStd = Number(np.std(np.subtract(noisy, clean)));
const recoveredStd = Number(np.std(error));
console.log('Noise std (before filter):', noisyStd.toFixed(4));
console.log('Residual std (after filter):', recoveredStd.toFixed(4));`}
  showImportHeader={true}
  showCopyButton={true}
/>

---

## Using fftfreq and fftshift

`fftfreq` returns the frequency bins for each FFT output element. `fftshift` rearranges the output so that the zero-frequency component is at the center, which is the standard convention for visualization.

<Playground
  code={String.raw`const N = 8;
const sampleSpacing = 1 / 8;  // 8 Hz sample rate

// fftfreq returns frequencies in "standard" order:
// [0, positive..., negative...] (Hz)
const freqs = np.fft.fftfreq(N, sampleSpacing);
console.log('fftfreq:', freqs, '\n');

// fftshift centers the zero frequency:
// [negative..., 0, positive...] — standard for visualization
const shiftedFreqs = np.fft.fftshift(freqs);
console.log('fftshift:', shiftedFreqs, '\n');

// For real-valued signals, rfftfreq returns only the positive frequencies
const rfreqs = np.fft.rfftfreq(N, sampleSpacing);
console.log('rfftfreq:', rfreqs, '\n');

// Use ifftshift to undo the shift before calling ifft
const unshifted = np.fft.ifftshift(shiftedFreqs);
console.log('ifftshift round-trip matches:', np.allclose(unshifted, freqs));`}
  showImportHeader={true}
  showCopyButton={true}
/>

---

## Convolution with a kernel

Convolution is fundamental to signal processing -- it is used for smoothing, differentiation, edge detection, and more. numpy-ts provides `convolve` for 1-D convolution.

<Playground
  code={String.raw`// Create a noisy step signal
const step = np.concatenate([np.zeros([50]), np.ones([50])]);
np.random.seed(42);
const noisy = np.add(step, np.multiply(np.random.normal(0, 1, [100]), 0.3));

// Moving average kernel (smoothing filter)
const kernelSize = 7;
const smoothKernel = np.full([kernelSize], 1.0 / kernelSize);

// Apply convolution
const smoothed = np.convolve(noisy, smoothKernel, 'same');

// Smoothing reduces noise — compare std dev before and after
const noisyStd = Number(np.std(np.subtract(noisy, step))).toFixed(3);
const smoothStd = Number(np.std(np.subtract(smoothed, step))).toFixed(3);
console.log('Noise std (before smoothing):', noisyStd);
console.log('Noise std (after smoothing):', smoothStd, '\n');

// Differentiation kernel (first derivative approximation)
const diffKernel = np.array([-1, 0, 1]);
const derivative = np.convolve(step, diffKernel, 'same');

// The derivative should spike at the step transition (index ~50)
const absDeriv = derivative.absolute();
const peakIdx = Number(np.argmax(absDeriv));
console.log('Derivative peak at index:', peakIdx, '(step transition is at 50)');
console.log('Derivative peak magnitude:', Number(absDeriv.get([peakIdx])), '\n');

// Edge detection kernel (Laplacian approximation)
const edgeKernel = np.array([1, -2, 1]);
const edges = np.convolve(step, edgeKernel, 'same');
const edgePeak = Number(np.argmax(np.absolute(edges)));
console.log('Edge detected at index:', edgePeak);`}
  showImportHeader={true}
  showCopyButton={true}
/>

<Note>
The `'same'` mode returns output with the same length as the input, `'full'` returns the full convolution (length M+N-1), and `'valid'` returns only the part computed without zero-padded edges.
</Note>

---

## Real FFT for real-valued signals

When your input is purely real (no imaginary component), `rfft` is more efficient than `fft` because it exploits the conjugate symmetry of the spectrum.

<Playground
  code={String.raw`const N = 1024;
const t = np.linspace(0, 1, N);
const signal = np.sin(np.multiply(t, 2 * Math.PI * 50));

// rfft is ~2x faster and returns only positive frequencies
const rfftResult = np.fft.rfft(signal);
console.log('Input length:', N);
console.log('rfft output length:', rfftResult.shape[0], '(= N/2 + 1 =', N/2 + 1 + ')', '\n');

// Corresponding frequencies
const rfreqs = np.fft.rfftfreq(N, 1.0 / N);
console.log('Frequency bins:', rfreqs.shape[0], '\n');

// The peak should be at 50 Hz
const mag = np.absolute(rfftResult);
const peakIdx = Number(np.argmax(mag));
console.log('Peak frequency:', Number(rfreqs.get([peakIdx])), 'Hz (expected: 50)', '\n');

// Inverse: irfft recovers the original real signal
const recovered = np.fft.irfft(rfftResult);
console.log('Recovered shape:', recovered.shape);
console.log('Round-trip matches original:', np.allclose(recovered, signal));`}
  showImportHeader={true}
  showCopyButton={true}
/>
