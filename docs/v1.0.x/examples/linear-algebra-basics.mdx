---
title: "Linear Algebra Basics"
description: "Solve linear systems, decompose matrices, compute inverses, and multiply matrices using numpy-ts."
---

import { Playground } from '/snippets/Playground.jsx'

## Solving a linear system Ax = b

Given a system of linear equations represented as a matrix equation `Ax = b`, use `linalg.solve` to find `x`.

<Playground
  code={String.raw`// System of equations:
//   2x + y = 5
//   x + 3y = 7
const A = np.array([[2, 1], [1, 3]]);
const b = np.array([5, 7]);

const x = np.linalg.solve(A, b);
console.log('x =', x, '\n');

// Verify: A @ x should equal b (matrix-vector product)
const check = np.dot(A, x);
console.log('A @ x =', check);`}
  showImportHeader={true}
  showCopyButton={true}
/>

For larger systems, `linalg.solve` is numerically stable and much faster than computing `inv(A) @ b`.

<Playground
  code={String.raw`// 3x3 system
const A3 = np.array([
  [1, 2, 3],
  [4, 5, 6],
  [7, 8, 10],
]);

const b3 = np.array([6, 15, 25]);

const x3 = np.linalg.solve(A3, b3);
console.log(x3);`}
  showImportHeader={true}
  showCopyButton={true}
/>

---

## Eigenvalue decomposition

Decompose a square matrix into its eigenvalues and eigenvectors with `linalg.eig`.

<Playground
  code={String.raw`const A = np.array([[4, -2], [1, 1]]);

const { w, v } = np.linalg.eig(A);

console.log('Eigenvalues:', w, '\n');
console.log('Eigenvectors:\n', v, '\n');`}
  showImportHeader={true}
  showCopyButton={true}
/>

For symmetric matrices, use `linalg.eigh` which is faster and guarantees real eigenvalues:

<Playground
  code={String.raw`const S = np.array([[2, 1], [1, 3]]);
const { w, v } = np.linalg.eigh(S);

console.log('Eigenvalues:', w, '\n');
console.log('Eigenvectors:\n', v, '\n');`}
  showImportHeader={true}
  showCopyButton={true}
/>

---

## Singular Value Decomposition (SVD)

SVD factors any matrix `A` into `U * S * V^T`. This is the foundation for dimensionality reduction, pseudoinverse computation, and low-rank approximation.

<Playground
  code={String.raw`const A = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]);

const { u, s, vt } = np.linalg.svd(A);

console.log('U shape:', u.shape);
console.log('S:', s);
console.log('Vt shape:', vt.shape, '\n');

// Low-rank approximation: keep only the first k singular values
const k = 2;

// Reconstruct using the top-k components
const Uk = u.slice(':', '0:' + k);
const Sk = np.diag(s.slice('0:' + k));
const Vtk = vt.slice('0:' + k, ':');

const A_approx = np.matmul(np.matmul(Uk, Sk), Vtk);
console.log('Rank-2 approximation:');
console.log(A_approx);`}
  showImportHeader={true}
  showCopyButton={true}
/>

---

## Matrix inverse and pseudo-inverse

<Playground
  code={String.raw`// Standard inverse (square, non-singular matrices)
const A = np.array([[1, 2], [3, 4]]);
const Ainv = np.linalg.inv(A);
console.log('Ainv:\n', Ainv, '\n');

// Verify: A @ A_inv = I
const I = np.matmul(A, Ainv);
console.log('A @ Ainv =\n', I, '\n');

// Determinant
const det = np.linalg.det(A);
console.log('det(A):', det); // -2

// Moore-Penrose pseudo-inverse (works on any matrix, including non-square)
const B = np.array([[1, 2], [3, 4], [5, 6]]);
const Bpinv = np.linalg.pinv(B);
console.log('B shape:', B.shape);
console.log('pinv shape:', Bpinv.shape);

// Verify: B @ pinv(B) @ B ~= B
const check = np.matmul(np.matmul(B, Bpinv), B);
console.log('B @ pinv(B) @ B ~= B:', np.allclose(check, B));`}
  showImportHeader={true}
  showCopyButton={true}
/>

---

## Matrix multiplication with matmul and dot

numpy-ts provides several ways to multiply matrices and vectors, each suited to different use cases.

<Playground
  code={String.raw`const A = np.array([[1, 2], [3, 4]]);
const B = np.array([[5, 6], [7, 8]]);

// matmul: standard matrix multiplication (equivalent to @ in Python)
const C = np.matmul(A, B);
console.log('A @ B =\n', C, '\n');

// dot: same result for 2-D arrays
const D = np.dot(A, B);
console.log('A dot B =\n', D, '\n');

// Vector dot product
const u = np.array([1, 2, 3]);
const v = np.array([4, 5, 6]);
console.log('u dot v =', np.dot(u, v), '\n');

// Matrix-vector product
const w = np.matmul(A, np.array([[1], [0]]));
console.log('A @ [1, 0] =\n', w, '\n');

// Method chaining (full entry point)
const result = A.matmul(B).add(1);
console.log('A.matmul(B).add(1) =\n', result, '\n');`}
  showImportHeader={true}
  showCopyButton={true}
/>
